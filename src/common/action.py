from typing import List, Dict, Any, Optional, Union
from numpy import ndarray
import uuid
import numpy as np

class Action:
    """
    Represents an action in the graph.
    Attributes:
        origin_node: The starting node of the action.
        destination_node: The ending node of the action.
        cost: The cost associated with this action.
        contribution_vector: The contribution vector of the action.
        trans_min_input: Dict describing minimum amount of each resource needed for the action to happen. A better name would be `min_resource_vector`.
        trans_term_vec: Dict describing resource consumption. Resource consumption is defined to be negative if a resource is used. A better name would be `resource_consumption_vector`.
        trans_term_min: Dict describing the maximum amount of a resource allowed for the action to happen. A better name would be `max_resource_vector`.

    """

    def __init__(self,trans_min_input,trans_term_add,trans_term_min,node_tail,node_head,Exog_vec,cost):
        self.trans_min_input=trans_min_input #min input term assocatied with an action
        self.trans_term_add=trans_term_add #addition term assocaited with an action
        self.trans_term_min=trans_term_min  #minimum transition term associated with an action 
        self.node_tail=node_tail  #this is the node from which  the action starts at 
        self.node_head=node_head #this is the node from whihc the action ends at 
        #self.action_id=action_id# this is the id associated wit hteh action
        self.Exog_vec=Exog_vec #exogenous contribution vector
        self.cost=cost #cost for the action
        self.non_zero_indices_exog=self.construct_non_zero_indices
        self.action_id = uuid.uuid4()

    def construct_non_zero_indices(self):
        self.non_zero_indices_exog=np.nonzero(self.Exog_vec)

    def comp_red_cost(self,dual_vec):
        #Computes the reduced cost by mulitplying the dual vector times teh exogenous.  
        return self.cost-np.sum(self.Exog_vec*dual_vec)
    
    def get_head_state(self,state_tail):
        #Grab the head state that would be generated by taking action a in state state_tail
        head_state=None
        if np.min(state_tail.state_vec-self.trans_min_input)>=0:#check if we can make a transition from this state 
            head_state=np.minimum(state_tail+self.trans_term_add,self.trans_term_min)#add teh altered state
        return head_state 

    def get_tail_state(self,state_head):
        #grab the lowest value tail state  that would generate this head state.  Does this by subtracting off the term that was added in
        pred_tail_state_left=state_head-self.trans_term_add #get the predecessor tate applying addition in reverse
        tail_state=np.maximum(pred_tail_state_left,self.trans_min_input)# covers pathological case
        return tail_state# returns the tail state

    def get_is_dominated(self,otherAction):
        #find out if this action dominates the input action 
        this_dominates_input=False
        if self.node_head!=otherAction.node_head or  self.node_tail!=otherAction.node_tail:
            #please dont comment this out if ogyuant code to be fast
            input('I should not have been called here if you are looping over all actions pairs that is inefficient')
        term_1=self.cost<=otherAction.cost #find out if the cost is at least as good as input
        term_2=0<=np.maximum(self.Exog_vec-otherAction.Exog_vec) #find out if this action has at least as good exog vector
        #
        term_1_strict=self.cost<otherAction.cost #find out if the cost is strictly better input
        term_2_strict=np.sum(self.Exog_vec-otherAction.Exog_vec)>0 #find out if the exogenous is srictly better at some point
        term_3=term_1_strict or term_2_strict #find out if a strict domination occurs at some point
        if term_1 and term_2 and term_3: #if at least as good and strictly better at soem point return true
            this_dominates_input=True #set the domination to true

        return this_dominates_input #return the domination property
    
    def is_null_action(self):
        """
        identifies if current action is a null action
        """
        return (self.origin_node == self.destination_node and
                self.cost == 0.0 and
                all(v == 0 for v in self.contribution_vector))
    

    def __eq__(self, other: "Action") -> bool:
        """
        Checks for equality based on the following fields:
          trans_min_input, trans_term_add, trans_term_min, node_tail,
          node_head, Exog_vec, cost
        """
        if not isinstance(other, Action):
            return False

        return (
            self.trans_min_input == other.trans_min_input and
            self.trans_term_add  == other.trans_term_add  and
            self.trans_term_min  == other.trans_term_min  and
            self.node_tail       == other.node_tail       and
            self.node_head       == other.node_head       and
            self.Exog_vec        == other.Exog_vec        and
            self.cost            == other.cost
        )

    def __hash__(self):
        """
        Creates a hash based on the fields used in __eq__.
        - Dictionaries are not hashable, so we convert them to frozensets of items.
        """
        return hash((
            frozenset(self.trans_min_input.items()),
            frozenset(self.trans_term_add.items()),
            frozenset(self.trans_term_min.items()),
            self.node_tail,
            self.node_head,
            frozenset(self.Exog_vec.items()),
            self.cost
        ))